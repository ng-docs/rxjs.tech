{
  "id": "api/index/function/observeOn",
  "title": "observeOn",
  "contents": "\n\n<article>\n  <div class=\"page-actions\">\n    <a href=\"https://github.com/reactivex/rxjs/edit/master/src/internal/operators/observeOn.ts?message=docs(index)%3A%20describe%20your%20change...#L6-L91\" aria-label=\"编辑建议\" title=\"编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n    <a href=\"https://github.com/reactivex/rxjs/tree/7.5.2/src/internal/operators/observeOn.ts#L6-L91\" aria-label=\"查看源码\" title=\"查看源码\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">code</i></a>\n  </div>\n    <div class=\"breadcrumb\">\n      <script type=\"application/ld+json\">\n        {\n          \"@context\": \"http://schema.org\",\n          \"@type\": \"BreadcrumbList\",\n          \"itemListElement\": [\n          { \"@type\": \"ListItem\", \"position\": 1, \"item\": { \"@id\": \"https://angular.io//api\", \"name\": \"API\" } },\n          { \"@type\": \"ListItem\", \"position\": 2, \"item\": { \"@id\": \"https://angular.io/api/index\", \"name\": \"rxjs/index\" } },\n          { \"@type\": \"ListItem\", \"position\": 3, \"item\": { \"@id\": \"https://angular.io/api/index/function/observeOn\", \"name\": \"observeOn\" } }\n          ]\n        }\n      </script>\n      <a href=\"/api\">API</a> / <a href=\"api/index\">rxjs/index</a>\n    </div>\n  <header class=\"api-header\">\n    <h1 id=\"observeon\">observeOn<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/index/function/observeOn#observeon\"><i class=\"material-icons\">link</i></a></h1>\n    <label class=\"api-type-label function\">function</label>\n    \n    \n    <label class=\"api-status-label stable\">稳定</label>\n    \n    <label class=\"api-status-label operator\">操作符</label>\n  </header>\n  <aio-toc class=\"embedded\"></aio-toc>\n\n  <div class=\"api-body\">\n    \n  \n\n  <p class=\"short-description\"></p><p translation-result=\"on\">使用指定的调度器从源 Observable 重新发送所有通知。</p><p translation-origin=\"off\">Re-emits all notifications from source Observable with specified scheduler.</p>\n\n<p></p>\n  \n\n  \n\n  \n\n  <code-example language=\"ts\" hidecopy=\"true\" class=\"no-box api-heading\"> <a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>&#x3C;T>(scheduler: <a href=\"api/index/interface/SchedulerLike\" class=\"code-anchor\">SchedulerLike</a>, <a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a>: number = 0): <a href=\"api/index/interface/MonoTypeOperatorFunction\" class=\"code-anchor\">MonoTypeOperatorFunction</a>&#x3C;T></code-example>\n\n\n\n\n  <h4 class=\"no-anchor\" id=\"parameters\">参数</h4>\n  <table class=\"is-full-width list-table parameters-table function-overload-parameters\">\n  <tbody>\n  \n    <tr class=\"function-overload-parameter\">\n      <td class=\"param-name\"><a id=\"\"></a>scheduler</td>\n      \n      <td class=\"param-description\">\n      <p translation-result=\"on\">一个调度器，用于重新调度来自源 Observable 的通知。</p><p translation-origin=\"off\">        Scheduler that will be used to reschedule notifications from source Observable.</p>\n\n\n      </td>\n    </tr>\n    <tr class=\"function-overload-parameter\">\n      <td class=\"param-name\"><a id=\"\"></a>delay</td>\n      \n      <td class=\"param-description\">\n      <p>        可选。默认值为 <code>0</code>。</p>\n<p translation-result=\"on\">一个毫秒数，用于指定重新调度每个通知的延迟时间。</p><p translation-origin=\"off\">        Number of milliseconds that states with what delay every notification should be rescheduled.</p>\n\n\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n  \n  <h4 class=\"no-anchor\" id=\"返回值\">返回值</h4>\n  <p translation-result=\"on\">一个返回 Observable 的函数，它会发送与源 Observable 相同的通知，但使用指定的调度器。</p><p translation-origin=\"off\"><code><a href=\"api/index/interface/MonoTypeOperatorFunction\" class=\"code-anchor\">MonoTypeOperatorFunction&#x3C;T></a></code>: A function that returns an Observable that emits the same\nnotifications as the source Observable, but with provided scheduler.</p>\n\n\n  \n\n\n\n\n\n\n\n  \n\n<section class=\"description\">\n  <h2 id=\"description\">说明<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/index/function/observeOn#description\"><i class=\"material-icons\">link</i></a></h2>\n  <p translation-result=\"on\"><span class=\"informal\">从 Observable 外部指定它使用某个特定的调度器。</span></p><p translation-origin=\"off\"><span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span></p>\n\n<p translation-result=\"on\"><code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 是可以通过第一个参数指定调度器的操作符，此调度器将用于重新调度源 Observable 发送的通知。如果你无法控制给定 Observable 的内部调度器，但仍想控制其值的发送时机，可以考虑使用此操作符。</p><p translation-origin=\"off\"><code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\nnotifications emitted by the source Observable. It might be useful, if you do not have control over\ninternal scheduler of a given Observable, but want to control when its values are emitted nevertheless.</p>\n\n<p translation-result=\"on\">返回的 Observable 会发送与源 Observable 相同的通知（下一个值、完成和出错事件），但会改用提供的调度器重新调度。请注意，这并不意味着源 Observables 内部调度器将以任何方式被替换。源仍然会被使用原来的调度器，但是当源 Observable 发出通知时，它会立即再次调度一次，但这次会改用传给 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 的调度器。这里有个反模式是在会同步发送大量值的 Observable 上调用 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code>，并异步将发出的值分成异步块。这种情况下，调度器将被迫直接传给源 Observable（而正常情况下会传给创建它的操作符）。<code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 只会稍微延迟通知，以确保它们在预期的时机发出。</p><p translation-origin=\"off\">Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\nbut rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\nscheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\nnotification, it will be immediately scheduled again - this time with scheduler passed to <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code>.\nAn anti-pattern would be calling <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> on Observable that emits lots of values synchronously, to split\nthat emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\nObservable directly (usually into the operator that creates it). <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> simply delays notifications a\nlittle bit more, to ensure that they are emitted at expected moments.</p>\n\n<p translation-result=\"on\">事实上，<code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 还能接受第二个参数，它以毫秒为单位指定将延迟多久发送通知。<a href=\"api/index/function/delay\"><code>delay</code></a> 操作符和 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 的主要区别在于 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 会延迟所有通知（包括错误通知）而 <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code> 会在源 Observable 发送错误通知时立即传递它。一般来说，强烈建议对流中的任何类型的值延迟使用 <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code> 操作符，而一般会用 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 来指定应该使用哪个调度器来发送通知。</p><p translation-origin=\"off\">As a matter of fact, <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> accepts second parameter, which specifies in milliseconds with what delay notifications\nwill be emitted. The main difference between <a href=\"api/index/function/delay\"><code>delay</code></a> operator and <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> is that <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code>\nwill delay all notifications - including error notifications - while <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code> will pass through error\nfrom source Observable immediately when it is emitted. In general it is highly recommended to use <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code> operator\nfor any kind of delaying of values in the stream, while using <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> to specify which scheduler should be used\nfor notification emissions in general.</p>\n\n<h2 id=\"example\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/index/function/observeOn#example\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"example\">Example<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/index/function/observeOn#example\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">确保在浏览器重绘之前先调用 subscribe 中的值</p><p translation-origin=\"off\">Ensure values in subscribe are called just before browser repaint</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>, <a href=\"api/index/const/animationFrameScheduler\" class=\"code-anchor\">animationFrameScheduler</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst someDiv = document.createElement('div');\nsomeDiv.style.cssText = 'width: 200px;background: #09c';\ndocument.body.appendChild(someDiv);\nconst intervals = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(10);      // Intervals are <a href=\"api/index/function/scheduled\" class=\"code-anchor\">scheduled</a>\n                                     // with async scheduler by default...\nintervals.pipe(\n  <a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>(<a href=\"api/index/const/animationFrameScheduler\" class=\"code-anchor\">animationFrameScheduler</a>) // ...but we will observe on <a href=\"api/index/const/animationFrame\" class=\"code-anchor\">animationFrame</a>\n)                                    // scheduler to ensure smooth animation.\n.subscribe(val => {\n  someDiv.style.height = val + 'px';\n});\n</code-example>\n\n</section>\n\n\n\n\n  \n\n  \n<section class=\"see-also\">\n  <h2 id=\"see-also\">参见<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/index/function/observeOn#see-also\"><i class=\"material-icons\">link</i></a></h2>\n  <ul>\n  \n    <li><a href=\"api/index/function/delay\"><code>delay</code></a>\n</li>\n  </ul>\n</section>\n\n\n\n  </div>\n</article>\n\n<!-- links to this doc:\n - api/index\n - api/index/class/Notification\n - api/index/function/throwError\n - api/operators/observeOn\n - deprecations/breaking-changes\n - guide/scheduler\n-->\n<!-- links from this doc:\n - /api\n - api/index\n - api/index/const/animationFrame\n - api/index/const/animationFrameScheduler\n - api/index/function/delay\n - api/index/function/from\n - api/index/function/interval\n - api/index/function/observeOn#description\n - api/index/function/observeOn#example\n - api/index/function/observeOn#observeon\n - api/index/function/observeOn#see-also\n - api/index/function/scheduled\n - api/index/interface/MonoTypeOperatorFunction\n - api/index/interface/SchedulerLike\n - https://github.com/reactivex/rxjs/edit/master/src/internal/operators/observeOn.ts?message=docs(index)%3A%20describe%20your%20change...#L6-L91\n - https://github.com/reactivex/rxjs/tree/7.5.2/src/internal/operators/observeOn.ts#L6-L91\n-->"
}