{
  "id": "deprecations/to-promise",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1 id=\"conversion-to-promises\" translation-result=\"on\">转换为 Promise（承诺）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#conversion-to-promises\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"conversion-to-promises\">Conversion to Promises<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#conversion-to-promises\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">Observables 和 Promises 的相似之处在于，随着时间的推移，这两个<a href=\"/guide/observable\">集合</a>都可能产生值，但不同之处在于 Observables 可能不产生或产生多个值，而 Promises 在成功解析时只产生一个值。</p><p translation-origin=\"off\">The similarity between Observables and Promises is that both <a href=\"/guide/observable\">collections</a> may produce values over time, but the difference is that Observables may produce none or more than one value, while Promises produce only one value when resolved successfully.</p>\n\n<h1 id=\"issues\" translation-result=\"on\">问题<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#issues\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"issues\">Issues<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#issues\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">出于这个原因，在 RxJS 7 中，Observable 的 <a href=\"/api/index/class/Observable#toPromise\"><code>toPromise()</code></a> 方法的返回类型已被修复，以更好地反映 Observable 可以产生零个值的事实。这可能对于某些项目是<strong>重大更改</strong>，因为返回类型已从 <code>Promise&#x3C;T></code> 更改为 <code>Promise&#x3C;T | undefined></code>。</p><p translation-origin=\"off\">For this reason, in RxJS 7, the return type of the Observable's <a href=\"/api/index/class/Observable#toPromise\"><code>toPromise()</code></a>\nmethod has been fixed to better reflect the fact that Observables can yield zero values. This may be a <strong>breaking change</strong> to some projects as the return type was changed from <code>Promise&#x3C;T></code> to <code>Promise&#x3C;T | undefined></code>.</p>\n\n<p translation-result=\"on\">此外，<code>toPromise()</code> 这个方法名无法指出 Promise 将使用什么发出的值来解决（resolve），因为 Observables 可以随着时间的推移产生多个值。转换为 Promise 时，你可能需要选择要选取的值 - 是抵达的第一个值还是最后一个值。为了解决所有这些问题，我们决定弃用 <code>toPromise()</code>，并引入两个新的辅助函数来转换为 Promise。</p><p translation-origin=\"off\">Also, <code>toPromise()</code> method name was never indicating what emitted value a Promise will resolve with because Observables can produce multiple values over time. When converting to a Promise, you might want to choose which value to pick - either the first value that has arrived or the last one. To fix all these issues, we decided to deprecate <code>toPromise()</code>, and to introduce the two new helper functions for conversion to Promises.</p>\n\n<h1 id=\"use-one-of-the-two-new-functions\" translation-result=\"on\">使用两个新函数之一<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-one-of-the-two-new-functions\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"use-one-of-the-two-new-functions\">Use one of the two new functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-one-of-the-two-new-functions\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">作为已弃用的 <code>toPromise()</code> 方法的替代品，你应该使用两个内置静态转换函数 <a href=\"api/index/function/firstValueFrom\"><code>firstValueFrom</code></a> 或 <a href=\"api/index/function/lastValueFrom\"><code>lastValueFrom</code></a> 之一。</p><p translation-origin=\"off\">As a replacement to the deprecated <code>toPromise()</code> method, you should use one of the two built in static conversion functions <a href=\"api/index/function/firstValueFrom\"><code>firstValueFrom</code></a> or <a href=\"api/index/function/lastValueFrom\"><code>lastValueFrom</code></a>.</p>\n\n<h2 id=\"lastvaluefrom\"><code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#lastvaluefrom\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\"><code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 与 <code>toPromise()</code> 几乎完全相同，这意味着它将使用 Observable 完成时抵达的最后一个值进行解析，但当 Observable 完成时没有发出单个值时，其行为有所不同。当 Observable 完成但没有发出值时，<code>toPromise()</code> 将成功解析为 <code>undefined</code>（因此要更改返回类型），而 <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 将拒绝 <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a>。因此，<code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 的返回类型是 <code>Promise&#x3C;T></code>，就像 RxJS 6 中的 <code>toPromise()</code> 一样。</p><p translation-origin=\"off\">The <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> is almost exactly the same as <code>toPromise()</code> meaning that it will resolve with the last value that has arrived when the Observable completes, but with the difference in behavior when Observable completes without emitting a single value. When Observable completes without emitting, <code>toPromise()</code> will successfully resolve with <code>undefined</code> (thus the return type change), while the <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> will reject with the <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a>. Thus, the return type of the\n<code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> is <code>Promise&#x3C;T></code>, just like <code>toPromise()</code> had in RxJS 6.</p>\n\n<h3 id=\"example\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"example\">Example<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example\"><i class=\"material-icons\">link</i></a></h3>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/function/take\" class=\"code-anchor\">take</a>, <a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nasync function execute() {\n  const source$ = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(2000).pipe(<a href=\"api/index/function/take\" class=\"code-anchor\">take</a>(10));\n  const finalNumber = await <a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a>(source$);\n  console.log(`The final number is ${finalNumber}`);\n}\n\nexecute();\n\n// Expected output:\n// \"The final number is 9\"\n</code-example>\n<h2 id=\"firstvaluefrom\"><code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#firstvaluefrom\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\">但是，你可能希望在第一个值到达时获取它而不用等待 Observable 完成，因此你可以使用 <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code>。<code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> 将使用从 Observable 发出的第一个值解析 Promise，并将立即退订以保留资源。如果 Observable 已完成但没有发出任何值，则 <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> 也会以 <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a> 为参数进行拒绝。</p><p translation-origin=\"off\">However, you might want to take the first value as it arrives without waiting an Observable to complete, thus you can use <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code>. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> will resolve a Promise with the first value that was emitted from the Observable and will immediately unsubscribe to retain resources. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> will also reject with an <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a> if the Observable completes with no values emitted.</p>\n\n<h3 id=\"example-1\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example-1\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"example-1\">Example<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example-1\"><i class=\"material-icons\">link</i></a></h3>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nasync function execute() {\n  const source$ = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(2000);\n  const firstNumber = await <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>(source$);\n  console.log(`The <a href=\"api/index/function/first\" class=\"code-anchor\">first</a> number is ${firstNumber}`);\n}\n\nexecute();\n\n// Expected output:\n// \"The <a href=\"api/index/function/first\" class=\"code-anchor\">first</a> number is 0\"\n</code-example>\n<p translation-result=\"on\"><span class=\"informal\">如果源 Observable 出错，这两个函数都会返回一个拒绝的 Promise。Promise 将以 Observable 错误相同的错误为参数进行拒绝。</span></p><p translation-origin=\"off\"><span class=\"informal\">Both functions will return a Promise that rejects if the source Observable errors. The Promise will reject with the same error that the Observable has errored with.</span></p>\n\n<h1 id=\"use-default-value\" translation-result=\"on\">使用默认值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-default-value\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"use-default-value\">Use default value<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-default-value\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">如果你不希望在完成前没有发出值的情况下 <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 或 <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> 创建的 Promise 以 <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a> 为参数进行拒绝，则可以使用第二个参数。第二个参数应该是一个带有 <code>defaultValue</code> 参数的对象。当源 Observable 完成而没有发出值时，<code>defaultValue</code> 中的值将用于解析 Promise。</p><p translation-origin=\"off\">If you don't want Promises created by <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> or <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> to reject with <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a> if there were no emissions before completion, you can use the second parameter. The second parameter is expected to be an object with <code>defaultValue</code> parameter. The value in the <code>defaultValue</code> will be used to resolve a Promise when source Observable completes without emitted values.</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>, <a href=\"api/index/const/EMPTY\" class=\"code-anchor\">EMPTY</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst result = await <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>(<a href=\"api/index/const/EMPTY\" class=\"code-anchor\">EMPTY</a>, { defaultValue: 0 });\nconsole.log(result);\n\n// Expected output:\n// 0\n</code-example>\n<h1 id=\"warning\" translation-result=\"on\">警告<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#warning\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"warning\">Warning<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#warning\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">仅当你<em>知道</em>Observable 最终会完成时才应该使用 <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 函数。如果你<em>知道</em> Observable 将发出至少一个值<em>或</em>最终肯定会完成，则应该使用 <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> 函数。如果源 Observable 没有完成或发出值，则你最终会得到一个挂起的 Promise，并且可能所有异步函数的状态都被挂在内存中。为避免这种情况，可以考虑添加 <a href=\"api/index/function/timeout\"><code>timeout</code></a>、<a href=\"api/index/function/take\"><code>take</code></a>、<a href=\"api/index/function/takeWhile\"><code>takeWhile</code></a> 或 <a href=\"api/index/function/takeUntil\"><code>takeUntil</code></a> 等操作符。</p><p translation-origin=\"off\">Only use <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> function if you <em>know</em> an Observable will eventually complete. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> function should be used if you <em>know</em> an Observable will emit at least one value <em>or</em> will eventually complete. If the source Observable does not complete or emit, you will end up with a Promise that is hung up, and potentially all of the state of an async function hanging out in memory. To avoid this situation, look into adding something like <a href=\"api/index/function/timeout\"><code>timeout</code></a>, <a href=\"api/index/function/take\"><code>take</code></a>, <a href=\"api/index/function/takeWhile\"><code>takeWhile</code></a>, or\n<a href=\"api/index/function/takeUntil\"><code>takeUntil</code></a> amongst others.</p>\n\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/index/class/Observable#toPromise\n - /guide/observable\n - api/index/const/EMPTY\n - api/index/function/first\n - api/index/function/firstValueFrom\n - api/index/function/from\n - api/index/function/interval\n - api/index/function/lastValueFrom\n - api/index/function/take\n - api/index/function/takeUntil\n - api/index/function/takeWhile\n - api/index/function/timeout\n - api/index/interface/EmptyError\n - deprecations/to-promise#conversion-to-promises\n - deprecations/to-promise#example\n - deprecations/to-promise#example-1\n - deprecations/to-promise#firstvaluefrom\n - deprecations/to-promise#issues\n - deprecations/to-promise#lastvaluefrom\n - deprecations/to-promise#use-default-value\n - deprecations/to-promise#use-one-of-the-two-new-functions\n - deprecations/to-promise#warning\n-->"
}