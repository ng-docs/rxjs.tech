{
  "id": "guide/core-semantics",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1 id=\"rxjs-core-semantics\" translation-result=\"on\">RxJS 核心语义<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#rxjs-core-semantics\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"rxjs-core-semantics\">RxJS Core Semantics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#rxjs-core-semantics\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">从版本 8 开始，核心库中提供的所有 RxJS 操作符必须满足以下语义。在当前版本 7 中，所有操作符都应该满足以下语义（作为准则）。如果没有，我们需要在<a href=\"https://github.com/ReactiveX/rxjs/issues\">GitHub 上</a>跟踪问题。</p><p translation-origin=\"off\">Starting in version 8, all RxJS operators that are provided in the core library MUST meet the following semantics. In the current version, version 7, all operators SHOULD meet the following semantics (as guidelines). If they do not, we need to track the issue on <a href=\"https://github.com/ReactiveX/rxjs/issues\">GitHub</a>.</p>\n\n<h2 id=\"purpose\" translation-result=\"on\">目的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#purpose\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"purpose\">Purpose<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#purpose\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">这些语义的目的是为我们库的用户提供可预测的行为，并确保我们的许多不同操作符之间的行为一致。应该注意的是，在撰写本文时，我们并不总是遵守这些语义准则。本文档将作为即将发生的更改的目标，并尽可能地帮我们描述此库。这也是一份“活文件”，可能会发生变化。</p><p translation-origin=\"off\">The purpose of these semantics is provide predictable behavior for the users of our library, and to ensure consistent behavior between our many different operators. It should be noted that at the time of this writing, we don't always adhere to these semantic guidelines. This document is to serve as a goalpost for upcoming changes and work as much as it is to help describe the library. This is also a \"living document\" and is subject to change.</p>\n\n<h2 id=\"general-design-guidelines\" translation-result=\"on\">一般设计指南<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#general-design-guidelines\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"general-design-guidelines\">General Design Guidelines<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#general-design-guidelines\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><strong>操作符、构造函数和创建函数等函数在有多个参数的情况下应使用命名参数，并且第一个参数之后的参数往往不够明显。</strong> 应简化主要用例，使其无需配置即可工作。例如，<code>fakeFlattenMap(n => <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(n))</code> 很好，但 <code>fakeFlattenMap(n => <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(n), 1)</code> 的可读性不如 <code>fakeFlattenMap(n => <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(n), { maxConcurrent: 1 })</code>。其他的东西，比如 <code><a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(1, 2, 3)</code> 很明显，命名参数没有意义。</p><p translation-origin=\"off\"><strong>Functions such as operators, constructors, and creation functions, should use named parameters in cases where there is more than 1 argument, and arguments after the first are non-obvious.</strong> The primary use case should be streamlined to work without configuration. For example, <code>fakeFlattenMap(n => <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(n))</code> is fine, but <code>fakeFlattenMap(n => <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(n), 1)</code> is less readable than <code>fakeFlattenMap(n => <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(n), { maxConcurrent: 1 })</code>. Other things, like <code><a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(1, 2, 3)</code> are obvious enough that named parameters don't make\nsense.</p>\n\n<h2 id=\"operators\" translation-result=\"on\">操作符<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#operators\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"operators\">Operators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#operators\"><i class=\"material-icons\">link</i></a></h2>\n\n<ul>\n<li>\n<p translation-result=\"on\">必须是返回<a href=\"https://rxjs.dev/api/index/interface/OperatorFunction\">操作符函数的函数</a>。也就是 <code>(source: <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>&#x3C;In>) => <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>&#x3C;Out></code>。</p><p translation-origin=\"off\">MUST be a function that returns an <a href=\"https://rxjs.dev/api/index/interface/OperatorFunction\">operator function</a>. That is <code>(source: <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>&#x3C;In>) => <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>&#x3C;Out></code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">返回的操作符函数必须是<a href=\"https://en.wikipedia.org/wiki/Referential_transparency\">引用透明</a>的。也就是说，如果你要捕获操作符的返回值（例如 <code>const double => <a href=\"api/index/function/map\" class=\"code-anchor\">map</a>(x => x + x)</code>），你可以使用该值对任意多个 observables 进行任意操作，而无需更改任何底层操作符引用中的状态。（例如 <code>a$.pipe(double)</code> 和 <code>b$.pipe(double)</code>）。</p><p translation-origin=\"off\">The returned operator function MUST be <a href=\"https://en.wikipedia.org/wiki/Referential_transparency\">referentially transparent</a>. That is to say, that if you capture the return value of the operator (e.g. <code>const double => <a href=\"api/index/function/map\" class=\"code-anchor\">map</a>(x => x + x)</code>), you can use that value to operate on any many observables as you like without changing any underlying state in the operator reference. (e.g. <code>a$.pipe(double)</code> and <code>b$.pipe(double)</code>).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">操作函数返回的 observable 必须订阅到源。</p><p translation-origin=\"off\">The observable returned by the operator function MUST subscribe to the source.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果操作符所执行的操作可以表明它不会改变源输出的任何内容，则它必须返回对来源的引用。例如 <code><a href=\"api/index/function/take\" class=\"code-anchor\">take</a>(Infinity)</code> 或 <code><a href=\"api/index/function/skip\" class=\"code-anchor\">skip</a>(0)</code>。</p><p translation-origin=\"off\">If the operation performed by the operator can tell it not change anything about the output of the source, it MUST return the reference to the source. For example <code><a href=\"api/index/function/take\" class=\"code-anchor\">take</a>(Infinity)</code> or <code><a href=\"api/index/function/skip\" class=\"code-anchor\">skip</a>(0)</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">接受“通知者”的操作符，即另一个用于触发某些行为的可观察源，必须接受可以通过 <code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a></code> 转换为 <code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> 的任何类型。例如 <code><a href=\"api/index/function/takeUntil\" class=\"code-anchor\">takeUntil</a></code>。</p><p translation-origin=\"off\">Operators that accept a \"notifier\", that is another observable source that is used to trigger some behavior, must accept any type that can be converted to an <code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> with <code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a></code>. For example <code><a href=\"api/index/function/takeUntil\" class=\"code-anchor\">takeUntil</a></code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">接受“通知器”（如上所述）的操作符只能将来自通知器的下一个值看做“通知”。已发出完成事件的通知器不能用作通知源。</p><p translation-origin=\"off\">Operators that accept \"notifiers\" (as described above), MUST ONLY recognized next values from the notifier as \"notifications\". Emitted completions may not be used a source of notification.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">直接提供给操作符的“通知器”必须在订阅源<em>之前</em>订阅。通过提供给操作符的工厂函数创建的“通知器”应该尽早订阅。</p><p translation-origin=\"off\">\"Notifiers\" provided directly to the operator MUST be subscribed to <em>before</em> the source is subscribed to. \"Notifiers\" created via factory function provided to the operator SHOULD be subscribed to at the earliest possible moment.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">操作符函数返回的 observable 应该视为源的“消费者”。因此，消费者必须在知道不再需要值后立即退订源，然后再继续执行<em>任意</em>操作。</p><p translation-origin=\"off\">The observable returned by the operator function is considered to be the \"consumer\" of the source. As such, the consumer MUST unsubscribe from the source as soon as it knows it no longer needs values before proceeding to do <em>any</em> action.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在源完成后发生的事件应该在源已经终结(finalize)之后发生。这是为了确保终结代码始终发生在与事件相关的可预测时间范围内。</p><p translation-origin=\"off\">Events that happen after the completion of a source SHOULD happen after the source finalizes. This is to ensure that finalization always happens in a predictable time frame relative to the event.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>Error</code> 对象的保留时间不得超过必要的时间。这可能是内存压力的来源。</p><p translation-origin=\"off\"><code>Error</code> objects MUST NOT be retained longer than necessary. This is a possible source of memory pressure.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>Promise</code> 引用的保留时间不得超过必要的时间。这可能是内存压力的来源。</p><p translation-origin=\"off\"><code>Promise</code> references MUST NOT be retained longer than necessary. This is a possible source of memory pressure.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果他们对创建函数执行相关操作，他们应该只使用后缀 <code>With</code> 来共享创建函数的名称。（例如 <code><a href=\"api/index/function/concat\" class=\"code-anchor\">concat</a></code> 和 <code><a href=\"api/index/function/concatWith\" class=\"code-anchor\">concatWith</a></code>）。</p><p translation-origin=\"off\">IF they perform a related operation to a creation function, they SHOULD share the creation function's name only with the suffix <code>With</code>. (e.g. <code><a href=\"api/index/function/concat\" class=\"code-anchor\">concat</a></code> and <code><a href=\"api/index/function/concatWith\" class=\"code-anchor\">concatWith</a></code>).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">不应该有“结果选择器”。这是一个辅助参数，它提供了在执行操作符的主要操作之后“映射”值的能力。</p><p translation-origin=\"off\">SHOULD NOT have \"result selectors\". This is a secondary argument that provides the ability to \"map\" values after performing the primary operation of the operator.</p>\n\n</li>\n</ul>\n<h2 id=\"creation-functions\" translation-result=\"on\">创建函数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#creation-functions\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"creation-functions\">Creation Functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#creation-functions\"><i class=\"material-icons\">link</i></a></h2>\n\n<ul>\n<li>\n<p translation-result=\"on\">名称不得以 <code>With</code> 结尾。这是为创建函数的操作符计数器部分保留的。</p><p translation-origin=\"off\">Names MUST NOT end in <code>With</code>. That is reserved for the operator counter parts of creation functions.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">可以有“结果选择器”。这是第二个参数，它提供了在值从结果 observable 发出之前“映射”值的能力。</p><p translation-origin=\"off\">MAY have \"result selectors\". This is a secondary argument that provides the ability to \"map\" values before they're emitted from the resulting observable.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果创建函数接受“结果选择器”，则它不能在该结果选择器之前接受“n-参数”。相反，它应该接受一个数组或者可能是一个对象。(坏写法: <code>combineThings(sourceA$, sourceB$, (a, b) => a + b)</code> 好写法: <code>combineThings([sourceA$, sourceB$], (a, b) => a + b)</code>。在这种情况下，将结果选择器作为第二个参数而不是作为命名参数提供会更好，因为其用法相当明显。</p><p translation-origin=\"off\">IF the creation function accepts a \"result selector\", it must not accept \"n-arguments\" ahead of that result selector. Instead, it should accept an array or possibly an object. (bad: <code>combineThings(sourceA$, sourceB$, (a, b) => a + b)</code>, good: <code>combineThings([sourceA$, sourceB$], (a, b) => a + b)</code>. In this case, it may be okay to provide the result selector as a second argument, rather than as a named parameter, as the use should be fairly obvious.</p>\n\n</li>\n</ul>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/index/class/Observable\n - api/index/function/concat\n - api/index/function/concatWith\n - api/index/function/from\n - api/index/function/map\n - api/index/function/of\n - api/index/function/skip\n - api/index/function/take\n - api/index/function/takeUntil\n - guide/core-semantics#creation-functions\n - guide/core-semantics#general-design-guidelines\n - guide/core-semantics#operators\n - guide/core-semantics#purpose\n - guide/core-semantics#rxjs-core-semantics\n - https://en.wikipedia.org/wiki/Referential_transparency\n - https://github.com/ReactiveX/rxjs/issues\n - https://rxjs.dev/api/index/interface/OperatorFunction\n-->"
}