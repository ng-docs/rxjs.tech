{
  "id": "guide/higher-order-observables",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1 id=\"higher-order-observables\" translation-result=\"on\">高阶 Observable<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/higher-order-observables#higher-order-observables\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"higher-order-observables\">Higher-order Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/higher-order-observables#higher-order-observables\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">Observable 通常会发出普通值，如字符串和数字，但令人惊讶的是，经常有需要处理 Observable<em>的</em> Observable，即所谓的高阶 Observable。例如，假设你有一个会发出字符串的 Observable，这些字符串是你要获取的文件的 URL。代码可能如下所示：</p><p translation-origin=\"off\">Observables most commonly emit ordinary values like strings and numbers, but surprisingly often, it is necessary to handle Observables <em>of</em> Observables, so-called higher-order Observables. For example, imagine you have an Observable emitting strings that are the URLs of files you want to fetch. The code might look like this:</p>\n\n<code-example language=\"ts\">\nconst fileObservable = urlObservable.pipe(<a href=\"api/index/function/map\" class=\"code-anchor\">map</a>((url) => http.get(url)));\n</code-example>\n<p translation-result=\"on\"><code>http.get()</code> 会为每个 URL 返回一个 Observable。现在你有了一个 Observable<em>的</em> Observable，也就是高阶 Observable。</p><p translation-origin=\"off\"><code>http.get()</code> returns an Observable for each URL. Now you have an Observable <em>of</em> Observables, a higher-order Observable.</p>\n\n<p translation-result=\"on\">但是你如何使用更高阶的 Observable 呢？通常，通过<em>展平</em>来将高阶 Observable 转换为普通的 Observable。例如：</p><p translation-origin=\"off\">But how do you work with a higher-order Observable? Typically, by <em>flattening</em>: by converting a higher-order Observable into an ordinary Observable. For example:</p>\n\n<code-example language=\"ts\">\nconst fileObservable = urlObservable.pipe(<a href=\"api/index/function/concatMap\" class=\"code-anchor\">concatMap</a>((url) => http.get(url)));\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/index/function/concatMap\" class=\"code-anchor\">concatMap</a></code> 函数中返回的 Observable 通常称为所谓的“内部” Observable，而在这个上下文中，<code>urlObservable</code> 就是所谓的“外部” Observable。</p><p translation-origin=\"off\">The Observable returned in the <code><a href=\"api/index/function/concatMap\" class=\"code-anchor\">concatMap</a></code> function is usually referred to as a so-called \"inner\" Observable, while in this context the <code>urlObservable</code> is the so-called \"outer\" Observable.</p>\n\n<p translation-result=\"on\"><a href=\"/api/operators/concatMap\"><code>concatMap()</code></a> 操作符会订阅每个“内部” Observable，缓冲“外部” Observable 的所有进一步发送，并复制所有已发送的值，直到内部 Observable 完成，并继续处理“外部 Observable”的值。所有值都以这种方式连接。其它有用的展平操作符有</p><p translation-origin=\"off\">The <a href=\"/api/operators/concatMap\"><code>concatMap()</code></a> operator subscribes to each \"inner\" Observable, buffers all further emissions of the \"outer\" Observable, and copies all the emitted values until the inner Observable completes, and continues processing the values of the \"outer Observable\". All of the values are in that way concatenated. Other useful flattening operators are</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"/api/operators/mergeMap\"><code>mergeMap()</code></a> — 在每个内部 Observable 抵达时订阅它，然后在每个值抵达时发出这个值</p><p translation-origin=\"off\"><a href=\"/api/operators/mergeMap\"><code>mergeMap()</code></a> — subscribes to each inner Observable as it arrives, then emits each value as it arrives</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"/api/operators/switchMap\"><code>switchMap()</code></a> — 在第一个内部 Observable 抵达时订阅它，并在它抵达时发出每个值，但是当下一个内部 Observable 抵达时，退订前一个，并订阅新的。</p><p translation-origin=\"off\"><a href=\"/api/operators/switchMap\"><code>switchMap()</code></a> — subscribes to the first inner Observable when it arrives, and emits each value as it arrives, but when the next inner Observable arrives, unsubscribes to the previous one, and subscribes to the new one.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"/api/operators/exhaustMap\"><code>exhaustMap()</code></a> - 当第一个内部 Observable 抵达时订阅它，并在它抵达时发出每个值，丢弃所有新抵达的内部 Observable 直到第一个完成，然后等待下一个内部 Observable。</p><p translation-origin=\"off\"><a href=\"/api/operators/exhaustMap\"><code>exhaustMap()</code></a> — subscribes to the first inner Observable when it arrives, and emits each value as it arrives, discarding all newly arriving inner Observables until that first one completes, then waits for the next inner Observable.</p>\n\n</li>\n</ul>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/operators/concatMap\n - /api/operators/exhaustMap\n - /api/operators/mergeMap\n - /api/operators/switchMap\n - api/index/function/concatMap\n - api/index/function/map\n - guide/higher-order-observables#higher-order-observables\n-->"
}