{
  "id": "guide/subject",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1 id=\"subject\" translation-result=\"on\">主体<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#subject\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"subject\">Subject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#subject\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\"><strong>什么是主体？</strong> RxJS Subject 是一种特殊类型的 Observable，它允许将值多播到多个 Observer。虽然普通的 Observable 是单播的（每个订阅的 Observer 都拥有 Observable 的独立执行），但 Subjects 是多播的。</p><p translation-origin=\"off\"><strong>What is a Subject?</strong> An RxJS Subject is a special type of Observable that allows values to be multicasted to many Observers. While plain Observables are unicast (each subscribed Observer owns an independent execution of the Observable), Subjects are multicast.</p>\n\n<p translation-result=\"on\"><span class=\"informal\">Subject 类似于 Observable，但可以多播到多个 Observer。Subjects 就像 EventEmitters：它们维护着许多监听器的注册表。</span></p><p translation-origin=\"off\"><span class=\"informal\">A Subject is like an Observable, but can multicast to many Observers. Subjects are like EventEmitters: they maintain a registry of many listeners.</span></p>\n\n<p translation-result=\"on\"><strong>每个 Subject 都是 Observable。</strong>给定一个 Subject，你可以 <code>subscribe</code> 它，提供一个 Observer，它将开始正常接收值。从 Observer 的角度来看，它无法判断 Observable 的执行是来自普通的单播 Observable 还是来自 Subject。</p><p translation-origin=\"off\"><strong>Every Subject is an Observable.</strong> Given a Subject, you can <code>subscribe</code> to it, providing an Observer, which will start receiving values normally. From the perspective of the Observer, it cannot tell whether the Observable execution is coming from a plain unicast Observable or a Subject.</p>\n\n<p translation-result=\"on\">在 Subject 内部，<code>subscribe</code> 不会调用一次能给出值的新执行过程。它只是在一个 Observer 列表中注册给定的 Observer，类似于 <code>addListener</code> 通常在其它库和语言中的工作方式。</p><p translation-origin=\"off\">Internally to the Subject, <code>subscribe</code> does not invoke a new execution that delivers values. It simply registers the given Observer in a list of Observers, similarly to how <code>addListener</code> usually works in other libraries and languages.</p>\n\n<p translation-result=\"on\"><strong>每个 Subject 也都是 Observer。</strong>它是一个具有方法 <code>next(v)</code>、<code>error(e)</code> 和 <code>complete()</code> 的对象。要为 Subject 提供一个新值，只需调用 <code>next(theValue)</code>，它将被多播到注册进来监听 Subject 的 Observer。</p><p translation-origin=\"off\"><strong>Every Subject is an Observer.</strong> It is an object with the methods <code>next(v)</code>, <code>error(e)</code>, and <code>complete()</code>. To feed a new value to the Subject, just call <code>next(theValue)</code>, and it will be multicasted to the Observers registered to listen to the Subject.</p>\n\n<p translation-result=\"on\">在下面的示例中，我们有两个 Observer 附加到一个主体，我们向这个主体提供一些值：</p><p translation-origin=\"off\">In the example below, we have two Observers attached to a Subject, and we feed some values to the Subject:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;number>();\n\nsubject.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\nsubject.subscribe({\n  next: (v) => console.log(`observerB: ${v}`),\n});\n\nsubject.next(1);\nsubject.next(2);\n\n// Logs:\n// observerA: 1\n// observerB: 1\n// observerA: 2\n// observerB: 2\n</code-example>\n<p translation-result=\"on\">由于 Subject 是 Observer，这也意味着你可以提供 Subject 作为任意 Observable <code>subscribe</code> 的参数，如下面的示例所示：</p><p translation-origin=\"off\">Since a Subject is an Observer, this also means you may provide a Subject as the argument to the <code>subscribe</code> of any Observable, like the example below shows:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>, <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;number>();\n\nsubject.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\nsubject.subscribe({\n  next: (v) => console.log(`observerB: ${v}`),\n});\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = <a href=\"api/index/function/from\" class=\"code-anchor\">from</a>([1, 2, 3]);\n\nobservable.subscribe(subject); // You can subscribe providing a <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>\n\n// Logs:\n// observerA: 1\n// observerB: 1\n// observerA: 2\n// observerB: 2\n// observerA: 3\n// observerB: 3\n</code-example>\n<p translation-result=\"on\">使用上述方法，我们基本上只是通过 Subject 将单播 Observable 执行转换为多播。这展示了 Subjects 是让任何 Observable 执行共享给多个 Observers 的唯一方法。</p><p translation-origin=\"off\">With the approach above, we essentially just converted a unicast Observable execution to multicast, through the Subject. This demonstrates how Subjects are the only way of making any Observable execution be shared to multiple Observers.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a></code> 类型还有一些特化： <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code>、<code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code> 和 <code><a href=\"api/index/class/AsyncSubject\" class=\"code-anchor\">AsyncSubject</a></code>。</p><p translation-origin=\"off\">There are also a few specializations of the <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a></code> type: <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code>, <code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code>, and <code><a href=\"api/index/class/AsyncSubject\" class=\"code-anchor\">AsyncSubject</a></code>.</p>\n\n<h2 id=\"multicasted-observables\" translation-result=\"on\">多播 Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#multicasted-observables\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"multicasted-observables\">Multicasted Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#multicasted-observables\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">“多播 Observable”通过可能有许多订阅者的 Subject 来传递通知，而普通的“单播 Observable”仅向单个 Observer 发送通知。</p><p translation-origin=\"off\">A \"multicasted Observable\" passes notifications through a Subject which may have many subscribers, whereas a plain \"unicast Observable\" only sends notifications to a single Observer.</p>\n\n<p translation-result=\"on\"><span class=\"informal\">多播的 Observable 在底层使用 Subject 来让多个 Observer 看到相同的 Observable 执行过程。</span></p><p translation-origin=\"off\"><span class=\"informal\">A multicasted Observable uses a Subject under the hood to make multiple Observers see the same Observable execution.</span></p>\n\n<p translation-result=\"on\">在底层，这就是 <code><a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a></code> 操作符的工作方式： Observer 订阅底层主体，主体订阅源 Observable。下面的例子类似于前面使用 <code>observable.subscribe(subject)</code> 的例子：</p><p translation-origin=\"off\">Under the hood, this is how the <code><a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a></code> operator works: Observers subscribe to an underlying Subject, and the Subject subscribes to the source Observable. The following example is similar to the previous example which used <code>observable.subscribe(subject)</code>:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/from\" class=\"code-anchor\">from</a>, <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>, <a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst source = <a href=\"api/index/function/from\" class=\"code-anchor\">from</a>([1, 2, 3]);\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>();\nconst multicasted = source.pipe(<a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a>(subject));\n\n// These are, under the hood, `subject.subscribe({...})`:\nmulticasted.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\nmulticasted.subscribe({\n  next: (v) => console.log(`observerB: ${v}`),\n});\n\n// This is, under the hood, `source.subscribe(subject)`:\nmulticasted.connect();\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a></code> 返回一个看起来像普通 Observable 的 Observable，但在订阅时会像 Subject 一样工作。<code><a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a></code> 返回一个 <code><a href=\"api/index/class/ConnectableObservable\" class=\"code-anchor\">ConnectableObservable</a></code>，它只是一个带有 <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> 方法的 Observable。</p><p translation-origin=\"off\"><code><a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a></code> returns an Observable that looks like a normal Observable, but works like a Subject when it comes to subscribing. <code><a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a></code> returns a <code><a href=\"api/index/class/ConnectableObservable\" class=\"code-anchor\">ConnectableObservable</a></code>, which is simply an Observable with the <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> method.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> 方法对于确定共享的 Observable 何时开始执行非常重要。因为 <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> 在后台执行 <code>source.subscribe(subject)</code>，所以 <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> 返回一个订阅，你可以退订以取消共享的 Observable 执行过程。</p><p translation-origin=\"off\">The <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> method is important to determine exactly when the shared Observable execution will start. Because <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> does <code>source.subscribe(subject)</code> under the hood, <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> returns a Subscription, which you can unsubscribe from in order to cancel the shared Observable execution.</p>\n\n<h3 id=\"reference-counting\" translation-result=\"on\">引用计数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#reference-counting\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"reference-counting\">Reference counting<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#reference-counting\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">手动调用 <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> 并处理订阅通常很麻烦。通常，我们希望在第一个 Observer 抵达时<em>自动</em>连接，并在最后一个 Observer 退订时自动取消共享执行。</p><p translation-origin=\"off\">Calling <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> manually and handling the Subscription is often cumbersome. Usually, we want to <em>automatically</em> connect when the first Observer arrives, and automatically cancel the shared execution when the last Observer unsubscribes.</p>\n\n<p translation-result=\"on\">请考虑以下示例，其中发生了此列表中列出的订阅：</p><p translation-origin=\"off\">Consider the following example where subscriptions occur as outlined by this list:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">第一个 Observer 订阅了多播的 Observable</p><p translation-origin=\"off\">First Observer subscribes to the multicasted Observable</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>多播的 Observable 已连接</strong></p><p translation-origin=\"off\"><strong>The multicasted Observable is connected</strong></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>next</code> 值 <code>0</code> 被传递给第一个 Observer</p><p translation-origin=\"off\">The <code>next</code> value <code>0</code> is delivered to the first Observer</p>\n\n</li>\n<li>\n<p translation-result=\"on\">第二个 Observer 订阅了多播的 Observable</p><p translation-origin=\"off\">Second Observer subscribes to the multicasted Observable</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>next</code> 的值 <code>1</code> 被传递给第一个 Observer</p><p translation-origin=\"off\">The <code>next</code> value <code>1</code> is delivered to the first Observer</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>next</code> 的值 <code>1</code> 被传递给第二个 Observer</p><p translation-origin=\"off\">The <code>next</code> value <code>1</code> is delivered to the second Observer</p>\n\n</li>\n<li>\n<p translation-result=\"on\">第一个 Observer 退订多播的 Observable</p><p translation-origin=\"off\">First Observer unsubscribes from the multicasted Observable</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>next</code> 值 <code>2</code> 被传递给第二个 Observer</p><p translation-origin=\"off\">The <code>next</code> value <code>2</code> is delivered to the second Observer</p>\n\n</li>\n<li>\n<p translation-result=\"on\">第二个 Observer 退订多播的 Observable</p><p translation-origin=\"off\">Second Observer unsubscribes from the multicasted Observable</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>与多播的 Observable 的连接被退订</strong></p><p translation-origin=\"off\"><strong>The connection to the multicasted Observable is unsubscribed</strong></p>\n\n</li>\n</ol>\n<p translation-result=\"on\">为了通过显式调用 <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> 来实现这一点，我们编写了以下代码：</p><p translation-origin=\"off\">To achieve that with explicit calls to <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code>, we write the following code:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>, <a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst source = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(500);\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>();\nconst multicasted = source.pipe(<a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a>(subject));\nlet subscription1, subscription2, subscriptionConnect;\n\nsubscription1 = multicasted.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\n// We should call `<a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()` here, because the <a href=\"api/index/function/first\" class=\"code-anchor\">first</a>\n// subscriber to `multicasted` is interested in consuming values\nsubscriptionConnect = multicasted.connect();\n\nsetTimeout(() => {\n  subscription2 = multicasted.subscribe({\n    next: (v) => console.log(`observerB: ${v}`),\n  });\n}, 600);\n\nsetTimeout(() => {\n  subscription1.unsubscribe();\n}, 1200);\n\n// We should unsubscribe the shared <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> execution here,\n// because `multicasted` would have no more subscribers after this\nsetTimeout(() => {\n  subscription2.unsubscribe();\n  subscriptionConnect.unsubscribe(); // for the shared <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> execution\n}, 2000);\n</code-example>\n<p translation-result=\"on\">如果我们希望避免显式调用 <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code>，可以使用 ConnectableObservable 的 <code>refCount()</code> 方法（引用计数），它返回一个 Observable 来跟踪它有多少订阅者。当订阅者数量从 <code>0</code> 增加到 <code>1</code> 时，它会为我们调用 <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code>，从而开始共享执行。只有当订阅者数量从 <code>1</code> 减少到 <code>0</code> 时，才会完全退订，并停止进一步执行。</p><p translation-origin=\"off\">If we wish to avoid explicit calls to <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code>, we can use ConnectableObservable's <code>refCount()</code> method (reference counting), which returns an Observable that keeps track of how many subscribers it has. When the number of subscribers increases from <code>0</code> to <code>1</code>, it will call <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> for us, which starts the shared execution. Only when the number of subscribers decreases from <code>1</code> to <code>0</code> will it be fully unsubscribed, stopping further execution.</p>\n\n<p translation-result=\"on\"><span class=\"informal\"><code>refCount</code> 能使多播的 Observable 在第一个订阅者抵达时自动开始执行，并在最后一个订阅者离开时停止执行。</span></p><p translation-origin=\"off\"><span class=\"informal\"><code>refCount</code> makes the multicasted Observable automatically start executing when the first subscriber arrives, and stop executing when the last subscriber leaves.</span></p>\n\n<p translation-result=\"on\">下面是一个例子：</p><p translation-origin=\"off\">Below is an example:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>, <a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a>, refCount } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst source = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(500);\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>();\nconst refCounted = source.pipe(<a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a>(subject), refCount());\nlet subscription1, subscription2;\n\n// This calls `<a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()`, because\n// it is the <a href=\"api/index/function/first\" class=\"code-anchor\">first</a> subscriber to `refCounted`\nconsole.log('observerA subscribed');\nsubscription1 = refCounted.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\n\nsetTimeout(() => {\n  console.log('observerB subscribed');\n  subscription2 = refCounted.subscribe({\n    next: (v) => console.log(`observerB: ${v}`),\n  });\n}, 600);\n\nsetTimeout(() => {\n  console.log('observerA unsubscribed');\n  subscription1.unsubscribe();\n}, 1200);\n\n// This is when the shared <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> execution will stop, because\n// `refCounted` would have no more subscribers after this\nsetTimeout(() => {\n  console.log('observerB unsubscribed');\n  subscription2.unsubscribe();\n}, 2000);\n\n// Logs\n// observerA subscribed\n// observerA: 0\n// observerB subscribed\n// observerA: 1\n// observerB: 1\n// observerA unsubscribed\n// observerB: 2\n// observerB unsubscribed\n</code-example>\n<p translation-result=\"on\"><code>refCount()</code> 方法只存在于 ConnectableObservable 上，它返回一个 <code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code>，而不是另一个 ConnectableObservable。</p><p translation-origin=\"off\">The <code>refCount()</code> method only exists on ConnectableObservable, and it returns an <code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code>, not another ConnectableObservable.</p>\n\n<h2 id=\"behaviorsubject\" translation-result=\"on\">行为主体<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#behaviorsubject\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"behaviorsubject\">BehaviorSubject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#behaviorsubject\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Subjects 的变体之一是 <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code>，它具有“当前值”的概念。它存储发送给其消费者的最新值，并且每当有新的 Observer 订阅时，它将立即从 <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code> 接收到“当前值”。</p><p translation-origin=\"off\">One of the variants of Subjects is the <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code>, which has a notion of \"the current value\". It stores the latest value emitted to its consumers, and whenever a new Observer subscribes, it will immediately receive the \"current value\" from the <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code>.</p>\n\n<p translation-result=\"on\"><span class=\"informal\">BehaviorSubjects 对于表示“随时间变化的值”很有用。例如，生日事件流是一个主体，但一个人的年龄流是一个行为主体。</span></p><p translation-origin=\"off\"><span class=\"informal\">BehaviorSubjects are useful for representing \"values over time\". For instance, an event stream of birthdays is a Subject, but the stream of a person's age would be a BehaviorSubject.</span></p>\n\n<p translation-result=\"on\">在下面的示例中，BehaviorSubject 使用第一个 Observer 在订阅时收到的值 <code>0</code> 进行初始化。第二个 Observer 接收到值 <code>2</code>，即使它是在发送值 <code>2</code> 之后订阅的。</p><p translation-origin=\"off\">In the following example, the BehaviorSubject is initialized with the value <code>0</code> which the first Observer receives when it subscribes. The second Observer receives the value <code>2</code> even though it subscribed after the value <code>2</code> was sent.</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\nconst subject = new <a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a>(0); // 0 is the initial value\n\nsubject.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\n\nsubject.next(1);\nsubject.next(2);\n\nsubject.subscribe({\n  next: (v) => console.log(`observerB: ${v}`),\n});\n\nsubject.next(3);\n\n// Logs\n// observerA: 0\n// observerA: 1\n// observerA: 2\n// observerB: 2\n// observerA: 3\n// observerB: 3\n</code-example>\n<h2 id=\"replaysubject\" translation-result=\"on\">重播主体<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#replaysubject\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"replaysubject\">ReplaySubject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#replaysubject\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code> 与 <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code> 类似，它可以将旧值发送给新订阅者，但它也可以<em>记录</em> Observable 执行结果的一部分。</p><p translation-origin=\"off\">A <code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code> is similar to a <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code> in that it can send old values to new subscribers, but it can also <em>record</em> a part of the Observable execution.</p>\n\n<p translation-result=\"on\"><span class=\"informal\"><code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code> 会记录来自 Observable 执行的多个值，并将它们重播给新订阅者。</span></p><p translation-origin=\"off\"><span class=\"informal\">A <code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code> records multiple values from the Observable execution and replays them to new subscribers.</span></p>\n\n<p translation-result=\"on\">创建 <code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code> 时，你可以指定要重播的值的数量：</p><p translation-origin=\"off\">When creating a <code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code>, you can specify how many values to replay:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\nconst subject = new <a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a>(3); // <a href=\"api/index/function/buffer\" class=\"code-anchor\">buffer</a> 3 values for new subscribers\n\nsubject.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\n\nsubject.next(1);\nsubject.next(2);\nsubject.next(3);\nsubject.next(4);\n\nsubject.subscribe({\n  next: (v) => console.log(`observerB: ${v}`),\n});\n\nsubject.next(5);\n\n// Logs:\n// observerA: 1\n// observerA: 2\n// observerA: 3\n// observerA: 4\n// observerB: 2\n// observerB: 3\n// observerB: 4\n// observerA: 5\n// observerB: 5\n</code-example>\n<p translation-result=\"on\">除了缓冲区大小之外，你还可以指定一个以毫秒为单位的<em>窗口时间</em>，以确定记录的值可以存在多长时间。在以下示例中，我们使用 <code>100</code> 个元素的大型缓冲区，但窗口时间参数仅为 <code>500</code> 毫秒。</p><p translation-origin=\"off\">You can also specify a <em>window time</em> in milliseconds, besides of the buffer size, to determine how old the recorded values can be. In the following example we use a large buffer size of <code>100</code>, but a window time parameter of just <code>500</code> milliseconds.</p>\n\n<!-- skip-example -->\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\nconst subject = new <a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a>(100, 500 /* <a href=\"api/index/function/windowTime\" class=\"code-anchor\">windowTime</a> */);\n\nsubject.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\n\nlet i = 1;\nsetInterval(() => subject.next(i++), 200);\n\nsetTimeout(() => {\n  subject.subscribe({\n    next: (v) => console.log(`observerB: ${v}`),\n  });\n}, 1000);\n\n// Logs\n// observerA: 1\n// observerA: 2\n// observerA: 3\n// observerA: 4\n// observerA: 5\n// observerB: 3\n// observerB: 4\n// observerB: 5\n// observerA: 6\n// observerB: 6\n// ...\n</code-example>\n<h2 id=\"asyncsubject\" translation-result=\"on\">异步主体<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#asyncsubject\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"asyncsubject\">AsyncSubject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#asyncsubject\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">AsyncSubject 是一种变体，其中仅将 Observable 执行的最后一个值发送给其 Observer，并且仅在执行完成时发送。</p><p translation-origin=\"off\">The AsyncSubject is a variant where only the last value of the Observable execution is sent to its observers, and only when the execution completes.</p>\n\n<code-example language=\"js\">\nimport { <a href=\"api/index/class/AsyncSubject\" class=\"code-anchor\">AsyncSubject</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\nconst subject = new <a href=\"api/index/class/AsyncSubject\" class=\"code-anchor\">AsyncSubject</a>();\n\nsubject.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\n\nsubject.next(1);\nsubject.next(2);\nsubject.next(3);\nsubject.next(4);\n\nsubject.subscribe({\n  next: (v) => console.log(`observerB: ${v}`),\n});\n\nsubject.next(5);\nsubject.complete();\n\n// Logs:\n// observerA: 5\n// observerB: 5\n</code-example>\n<p translation-result=\"on\">AsyncSubject 类似于 <a href=\"/api/operators/last\"><code>last()</code></a> 操作符，因为它会等待 <code>complete</code> 通知以传递单个值。</p><p translation-origin=\"off\">The AsyncSubject is similar to the <a href=\"/api/operators/last\"><code>last()</code></a> operator, in that it waits for the <code>complete</code> notification in order to deliver a single value.</p>\n\n<h2 id=\"void-subject\" translation-result=\"on\">void 主体<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#void-subject\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"void-subject\">Void subject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#void-subject\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">有时，发出值这件事本身比所发出的值更重要。</p><p translation-origin=\"off\">Sometimes the emitted value doesn't matter as much as the fact that a value was emitted.</p>\n\n<p translation-result=\"on\">例如，下面的代码表示已经过了一秒钟。</p><p translation-origin=\"off\">For instance, the code below signals that one second has passed.</p>\n\n<code-example language=\"ts\">\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;string>();\nsetTimeout(() => subject.next('dummy'), 1000);\n</code-example>\n<p translation-result=\"on\">以这种方式传递一个虚拟值很笨拙，并且可能会使用户感到困惑。</p><p translation-origin=\"off\">Passing a dummy value this way is clumsy and can confuse users.</p>\n\n<p translation-result=\"on\">通过声明一个 <em>void 主体</em>，你可以表明该值是无所谓的。只有事件本身才重要。</p><p translation-origin=\"off\">By declaring a <em>void subject</em>, you signal that the value is irrelevant. Only the event itself matters.</p>\n\n<code-example language=\"ts\">\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;void>();\nsetTimeout(() => subject.next(), 1000);\n</code-example>\n<p translation-result=\"on\">带有上下文的完整示例如下所示：</p><p translation-origin=\"off\">A complete example with context is shown below:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>(); // Shorthand for <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;void>\n\nsubject.subscribe({\n  next: () => console.log('One second has passed'),\n});\n\nsetTimeout(() => subject.next(), 1000);\n</code-example>\n<p translation-result=\"on\"><span class=\"informal\">在版本 7 之前，Subject 值的默认类型是 <code>any</code>。<code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;any></code> 禁用发出值的类型检查，而 <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;void></code> 可以防止意外访问所发出的值。如果你想要老式行为，请将 <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a></code> 替换为 <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;any></code>。</span></p><p translation-origin=\"off\"><span class=\"informal\">Before version 7, the default type of Subject values was <code>any</code>. <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;any></code> disables type checking of the emitted values, whereas <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;void></code> prevents accidental access to the emitted value. If you want the old behavior, then replace <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a></code> with <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;any></code>.</span></p>\n\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/operators/last\n - api/index/class/AsyncSubject\n - api/index/class/BehaviorSubject\n - api/index/class/ConnectableObservable\n - api/index/class/Observable\n - api/index/class/ReplaySubject\n - api/index/class/Subject\n - api/index/const/observable\n - api/index/function/buffer\n - api/index/function/connect\n - api/index/function/first\n - api/index/function/from\n - api/index/function/interval\n - api/index/function/multicast\n - api/index/function/windowTime\n - guide/subject#asyncsubject\n - guide/subject#behaviorsubject\n - guide/subject#multicasted-observables\n - guide/subject#reference-counting\n - guide/subject#replaysubject\n - guide/subject#subject\n - guide/subject#void-subject\n-->"
}